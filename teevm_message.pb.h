// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: teevm_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_teevm_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_teevm_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_teevm_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_teevm_5fmessage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_teevm_5fmessage_2eproto;
namespace teevm {
class CallContractRequest;
struct CallContractRequestDefaultTypeInternal;
extern CallContractRequestDefaultTypeInternal _CallContractRequest_default_instance_;
class CallContractRequest_ArgsEntry_DoNotUse;
struct CallContractRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern CallContractRequest_ArgsEntry_DoNotUseDefaultTypeInternal _CallContractRequest_ArgsEntry_DoNotUse_default_instance_;
class ContractResponse;
struct ContractResponseDefaultTypeInternal;
extern ContractResponseDefaultTypeInternal _ContractResponse_default_instance_;
class ContractResponse_ReadMapEntry_DoNotUse;
struct ContractResponse_ReadMapEntry_DoNotUseDefaultTypeInternal;
extern ContractResponse_ReadMapEntry_DoNotUseDefaultTypeInternal _ContractResponse_ReadMapEntry_DoNotUse_default_instance_;
class ContractResponse_WriteMapEntry_DoNotUse;
struct ContractResponse_WriteMapEntry_DoNotUseDefaultTypeInternal;
extern ContractResponse_WriteMapEntry_DoNotUseDefaultTypeInternal _ContractResponse_WriteMapEntry_DoNotUse_default_instance_;
class CrossContext;
struct CrossContextDefaultTypeInternal;
extern CrossContextDefaultTypeInternal _CrossContext_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SysCallMessage;
struct SysCallMessageDefaultTypeInternal;
extern SysCallMessageDefaultTypeInternal _SysCallMessage_default_instance_;
class SysCallMessage_PayloadEntry_DoNotUse;
struct SysCallMessage_PayloadEntry_DoNotUseDefaultTypeInternal;
extern SysCallMessage_PayloadEntry_DoNotUseDefaultTypeInternal _SysCallMessage_PayloadEntry_DoNotUse_default_instance_;
class TeeContractEvent;
struct TeeContractEventDefaultTypeInternal;
extern TeeContractEventDefaultTypeInternal _TeeContractEvent_default_instance_;
class TeeVMMessage;
struct TeeVMMessageDefaultTypeInternal;
extern TeeVMMessageDefaultTypeInternal _TeeVMMessage_default_instance_;
class TxContext;
struct TxContextDefaultTypeInternal;
extern TxContextDefaultTypeInternal _TxContext_default_instance_;
class TxContext_ReadMapEntry_DoNotUse;
struct TxContext_ReadMapEntry_DoNotUseDefaultTypeInternal;
extern TxContext_ReadMapEntry_DoNotUseDefaultTypeInternal _TxContext_ReadMapEntry_DoNotUse_default_instance_;
class TxContext_WriteMapEntry_DoNotUse;
struct TxContext_WriteMapEntry_DoNotUseDefaultTypeInternal;
extern TxContext_WriteMapEntry_DoNotUseDefaultTypeInternal _TxContext_WriteMapEntry_DoNotUse_default_instance_;
class TxRequest;
struct TxRequestDefaultTypeInternal;
extern TxRequestDefaultTypeInternal _TxRequest_default_instance_;
class TxRequest_ParametersEntry_DoNotUse;
struct TxRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern TxRequest_ParametersEntry_DoNotUseDefaultTypeInternal _TxRequest_ParametersEntry_DoNotUse_default_instance_;
class TxResponse;
struct TxResponseDefaultTypeInternal;
extern TxResponseDefaultTypeInternal _TxResponse_default_instance_;
class TxResponse_ReadMapEntry_DoNotUse;
struct TxResponse_ReadMapEntry_DoNotUseDefaultTypeInternal;
extern TxResponse_ReadMapEntry_DoNotUseDefaultTypeInternal _TxResponse_ReadMapEntry_DoNotUse_default_instance_;
class TxResponse_WriteMapEntry_DoNotUse;
struct TxResponse_WriteMapEntry_DoNotUseDefaultTypeInternal;
extern TxResponse_WriteMapEntry_DoNotUseDefaultTypeInternal _TxResponse_WriteMapEntry_DoNotUse_default_instance_;
}  // namespace teevm
PROTOBUF_NAMESPACE_OPEN
template<> ::teevm::CallContractRequest* Arena::CreateMaybeMessage<::teevm::CallContractRequest>(Arena*);
template<> ::teevm::CallContractRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::CallContractRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::teevm::ContractResponse* Arena::CreateMaybeMessage<::teevm::ContractResponse>(Arena*);
template<> ::teevm::ContractResponse_ReadMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::ContractResponse_ReadMapEntry_DoNotUse>(Arena*);
template<> ::teevm::ContractResponse_WriteMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::ContractResponse_WriteMapEntry_DoNotUse>(Arena*);
template<> ::teevm::CrossContext* Arena::CreateMaybeMessage<::teevm::CrossContext>(Arena*);
template<> ::teevm::Response* Arena::CreateMaybeMessage<::teevm::Response>(Arena*);
template<> ::teevm::SysCallMessage* Arena::CreateMaybeMessage<::teevm::SysCallMessage>(Arena*);
template<> ::teevm::SysCallMessage_PayloadEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::SysCallMessage_PayloadEntry_DoNotUse>(Arena*);
template<> ::teevm::TeeContractEvent* Arena::CreateMaybeMessage<::teevm::TeeContractEvent>(Arena*);
template<> ::teevm::TeeVMMessage* Arena::CreateMaybeMessage<::teevm::TeeVMMessage>(Arena*);
template<> ::teevm::TxContext* Arena::CreateMaybeMessage<::teevm::TxContext>(Arena*);
template<> ::teevm::TxContext_ReadMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::TxContext_ReadMapEntry_DoNotUse>(Arena*);
template<> ::teevm::TxContext_WriteMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::TxContext_WriteMapEntry_DoNotUse>(Arena*);
template<> ::teevm::TxRequest* Arena::CreateMaybeMessage<::teevm::TxRequest>(Arena*);
template<> ::teevm::TxRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::TxRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::teevm::TxResponse* Arena::CreateMaybeMessage<::teevm::TxResponse>(Arena*);
template<> ::teevm::TxResponse_ReadMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::TxResponse_ReadMapEntry_DoNotUse>(Arena*);
template<> ::teevm::TxResponse_WriteMapEntry_DoNotUse* Arena::CreateMaybeMessage<::teevm::TxResponse_WriteMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace teevm {

enum TeeVMType : int {
  UNDEFINED = 0,
  REGISTER = 1,
  REGISTERED = 2,
  PREPARE = 3,
  READY = 4,
  INIT = 5,
  INVOKE = 6,
  TX_REQUEST = 7,
  TX_RESPONSE = 8,
  GET_STATE_REQUEST = 9,
  GET_STATE_RESPONSE = 10,
  GET_BYTECODE_REQUEST = 11,
  GET_BYTECODE_RESPONSE = 12,
  CALL_CONTRACT_REQUEST = 13,
  CALL_CONTRACT_RESPONSE = 14,
  COMPLETED = 15,
  ERROR = 16,
  CREATE_KV_ITERATOR_REQUEST = 17,
  CREATE_KV_ITERATOR_RESPONSE = 18,
  CONSUME_KV_ITERATOR_REQUEST = 19,
  CONSUME_KV_ITERATOR_RESPONSE = 20,
  CREATE_KEY_HISTORY_ITER_REQUEST = 21,
  CREATE_KEY_HISTORY_TER_RESPONSE = 22,
  CONSUME_KEY_HISTORY_ITER_REQUEST = 23,
  CONSUME_KEY_HISTORY_ITER_RESPONSE = 24,
  GET_SENDER_ADDRESS_REQUEST = 25,
  GET_SENDER_ADDRESS_RESPONSE = 26,
  TeeVMType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TeeVMType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TeeVMType_IsValid(int value);
constexpr TeeVMType TeeVMType_MIN = UNDEFINED;
constexpr TeeVMType TeeVMType_MAX = GET_SENDER_ADDRESS_RESPONSE;
constexpr int TeeVMType_ARRAYSIZE = TeeVMType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeeVMType_descriptor();
template<typename T>
inline const std::string& TeeVMType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeeVMType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeeVMType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeeVMType_descriptor(), enum_t_value);
}
inline bool TeeVMType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TeeVMType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeeVMType>(
    TeeVMType_descriptor(), name, value);
}
enum TeeVMCode : int {
  OK = 0,
  FAIL = 1,
  TeeVMCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TeeVMCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TeeVMCode_IsValid(int value);
constexpr TeeVMCode TeeVMCode_MIN = OK;
constexpr TeeVMCode TeeVMCode_MAX = FAIL;
constexpr int TeeVMCode_ARRAYSIZE = TeeVMCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeeVMCode_descriptor();
template<typename T>
inline const std::string& TeeVMCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeeVMCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeeVMCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeeVMCode_descriptor(), enum_t_value);
}
inline bool TeeVMCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TeeVMCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeeVMCode>(
    TeeVMCode_descriptor(), name, value);
}
// ===================================================================

class TeeVMMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.TeeVMMessage) */ {
 public:
  inline TeeVMMessage() : TeeVMMessage(nullptr) {}
  ~TeeVMMessage() override;
  explicit PROTOBUF_CONSTEXPR TeeVMMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeeVMMessage(const TeeVMMessage& from);
  TeeVMMessage(TeeVMMessage&& from) noexcept
    : TeeVMMessage() {
    *this = ::std::move(from);
  }

  inline TeeVMMessage& operator=(const TeeVMMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeeVMMessage& operator=(TeeVMMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeeVMMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeeVMMessage* internal_default_instance() {
    return reinterpret_cast<const TeeVMMessage*>(
               &_TeeVMMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TeeVMMessage& a, TeeVMMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TeeVMMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeeVMMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeeVMMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeeVMMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeeVMMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeeVMMessage& from) {
    TeeVMMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeeVMMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.TeeVMMessage";
  }
  protected:
  explicit TeeVMMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIdFieldNumber = 1,
    kChainIdFieldNumber = 7,
    kSignFieldNumber = 8,
    kCrossContextFieldNumber = 3,
    kSysCallMessageFieldNumber = 4,
    kRequestFieldNumber = 5,
    kResponseFieldNumber = 6,
    kTypeFieldNumber = 2,
  };
  // string tx_id = 1;
  void clear_tx_id();
  const std::string& tx_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_id();
  PROTOBUF_NODISCARD std::string* release_tx_id();
  void set_allocated_tx_id(std::string* tx_id);
  private:
  const std::string& _internal_tx_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_id(const std::string& value);
  std::string* _internal_mutable_tx_id();
  public:

  // string chain_id = 7;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // bytes sign = 8;
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // .teevm.CrossContext cross_context = 3;
  bool has_cross_context() const;
  private:
  bool _internal_has_cross_context() const;
  public:
  void clear_cross_context();
  const ::teevm::CrossContext& cross_context() const;
  PROTOBUF_NODISCARD ::teevm::CrossContext* release_cross_context();
  ::teevm::CrossContext* mutable_cross_context();
  void set_allocated_cross_context(::teevm::CrossContext* cross_context);
  private:
  const ::teevm::CrossContext& _internal_cross_context() const;
  ::teevm::CrossContext* _internal_mutable_cross_context();
  public:
  void unsafe_arena_set_allocated_cross_context(
      ::teevm::CrossContext* cross_context);
  ::teevm::CrossContext* unsafe_arena_release_cross_context();

  // .teevm.SysCallMessage sys_call_message = 4;
  bool has_sys_call_message() const;
  private:
  bool _internal_has_sys_call_message() const;
  public:
  void clear_sys_call_message();
  const ::teevm::SysCallMessage& sys_call_message() const;
  PROTOBUF_NODISCARD ::teevm::SysCallMessage* release_sys_call_message();
  ::teevm::SysCallMessage* mutable_sys_call_message();
  void set_allocated_sys_call_message(::teevm::SysCallMessage* sys_call_message);
  private:
  const ::teevm::SysCallMessage& _internal_sys_call_message() const;
  ::teevm::SysCallMessage* _internal_mutable_sys_call_message();
  public:
  void unsafe_arena_set_allocated_sys_call_message(
      ::teevm::SysCallMessage* sys_call_message);
  ::teevm::SysCallMessage* unsafe_arena_release_sys_call_message();

  // .teevm.TxRequest request = 5;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::teevm::TxRequest& request() const;
  PROTOBUF_NODISCARD ::teevm::TxRequest* release_request();
  ::teevm::TxRequest* mutable_request();
  void set_allocated_request(::teevm::TxRequest* request);
  private:
  const ::teevm::TxRequest& _internal_request() const;
  ::teevm::TxRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::teevm::TxRequest* request);
  ::teevm::TxRequest* unsafe_arena_release_request();

  // .teevm.TxResponse response = 6;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::teevm::TxResponse& response() const;
  PROTOBUF_NODISCARD ::teevm::TxResponse* release_response();
  ::teevm::TxResponse* mutable_response();
  void set_allocated_response(::teevm::TxResponse* response);
  private:
  const ::teevm::TxResponse& _internal_response() const;
  ::teevm::TxResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::teevm::TxResponse* response);
  ::teevm::TxResponse* unsafe_arena_release_response();

  // .teevm.TeeVMType type = 2;
  void clear_type();
  ::teevm::TeeVMType type() const;
  void set_type(::teevm::TeeVMType value);
  private:
  ::teevm::TeeVMType _internal_type() const;
  void _internal_set_type(::teevm::TeeVMType value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.TeeVMMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    ::teevm::CrossContext* cross_context_;
    ::teevm::SysCallMessage* sys_call_message_;
    ::teevm::TxRequest* request_;
    ::teevm::TxResponse* response_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SysCallMessage_PayloadEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SysCallMessage_PayloadEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SysCallMessage_PayloadEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  SysCallMessage_PayloadEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SysCallMessage_PayloadEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SysCallMessage_PayloadEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SysCallMessage_PayloadEntry_DoNotUse& other);
  static const SysCallMessage_PayloadEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SysCallMessage_PayloadEntry_DoNotUse*>(&_SysCallMessage_PayloadEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.SysCallMessage.PayloadEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class SysCallMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.SysCallMessage) */ {
 public:
  inline SysCallMessage() : SysCallMessage(nullptr) {}
  ~SysCallMessage() override;
  explicit PROTOBUF_CONSTEXPR SysCallMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SysCallMessage(const SysCallMessage& from);
  SysCallMessage(SysCallMessage&& from) noexcept
    : SysCallMessage() {
    *this = ::std::move(from);
  }

  inline SysCallMessage& operator=(const SysCallMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SysCallMessage& operator=(SysCallMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SysCallMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SysCallMessage* internal_default_instance() {
    return reinterpret_cast<const SysCallMessage*>(
               &_SysCallMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SysCallMessage& a, SysCallMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SysCallMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SysCallMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SysCallMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SysCallMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SysCallMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SysCallMessage& from) {
    SysCallMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SysCallMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.SysCallMessage";
  }
  protected:
  explicit SysCallMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, bytes> payload = 3;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_payload() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_payload();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      payload() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_payload();

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .teevm.TeeVMCode code = 1;
  void clear_code();
  ::teevm::TeeVMCode code() const;
  void set_code(::teevm::TeeVMCode value);
  private:
  ::teevm::TeeVMCode _internal_code() const;
  void _internal_set_code(::teevm::TeeVMCode value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.SysCallMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SysCallMessage_PayloadEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class CrossContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.CrossContext) */ {
 public:
  inline CrossContext() : CrossContext(nullptr) {}
  ~CrossContext() override;
  explicit PROTOBUF_CONSTEXPR CrossContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrossContext(const CrossContext& from);
  CrossContext(CrossContext&& from) noexcept
    : CrossContext() {
    *this = ::std::move(from);
  }

  inline CrossContext& operator=(const CrossContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossContext& operator=(CrossContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossContext* internal_default_instance() {
    return reinterpret_cast<const CrossContext*>(
               &_CrossContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CrossContext& a, CrossContext& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrossContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrossContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CrossContext& from) {
    CrossContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.CrossContext";
  }
  protected:
  explicit CrossContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessNameFieldNumber = 2,
    kCrossInfoFieldNumber = 3,
    kCurrentDepthFieldNumber = 1,
  };
  // string process_name = 2;
  void clear_process_name();
  const std::string& process_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process_name();
  PROTOBUF_NODISCARD std::string* release_process_name();
  void set_allocated_process_name(std::string* process_name);
  private:
  const std::string& _internal_process_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_name(const std::string& value);
  std::string* _internal_mutable_process_name();
  public:

  // uint64 cross_info = 3;
  void clear_cross_info();
  uint64_t cross_info() const;
  void set_cross_info(uint64_t value);
  private:
  uint64_t _internal_cross_info() const;
  void _internal_set_cross_info(uint64_t value);
  public:

  // uint32 current_depth = 1;
  void clear_current_depth();
  uint32_t current_depth() const;
  void set_current_depth(uint32_t value);
  private:
  uint32_t _internal_current_depth() const;
  void _internal_set_current_depth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.CrossContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_name_;
    uint64_t cross_info_;
    uint32_t current_depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class TxRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TxRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TxRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TxRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TxRequest_ParametersEntry_DoNotUse& other);
  static const TxRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TxRequest_ParametersEntry_DoNotUse*>(&_TxRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.TxRequest.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class TxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.TxRequest) */ {
 public:
  inline TxRequest() : TxRequest(nullptr) {}
  ~TxRequest() override;
  explicit PROTOBUF_CONSTEXPR TxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxRequest(const TxRequest& from);
  TxRequest(TxRequest&& from) noexcept
    : TxRequest() {
    *this = ::std::move(from);
  }

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxRequest& operator=(TxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxRequest* internal_default_instance() {
    return reinterpret_cast<const TxRequest*>(
               &_TxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TxRequest& a, TxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxRequest& from) {
    TxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.TxRequest";
  }
  protected:
  explicit TxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 4,
    kContractNameFieldNumber = 1,
    kContractVersionFieldNumber = 2,
    kMethodFieldNumber = 3,
    kTxContextFieldNumber = 5,
    kGasUsedFieldNumber = 6,
  };
  // map<string, bytes> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string contract_name = 1;
  void clear_contract_name();
  const std::string& contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_name();
  PROTOBUF_NODISCARD std::string* release_contract_name();
  void set_allocated_contract_name(std::string* contract_name);
  private:
  const std::string& _internal_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_name(const std::string& value);
  std::string* _internal_mutable_contract_name();
  public:

  // string contract_version = 2;
  void clear_contract_version();
  const std::string& contract_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_version();
  PROTOBUF_NODISCARD std::string* release_contract_version();
  void set_allocated_contract_version(std::string* contract_version);
  private:
  const std::string& _internal_contract_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_version(const std::string& value);
  std::string* _internal_mutable_contract_version();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .teevm.TxContext tx_context = 5;
  bool has_tx_context() const;
  private:
  bool _internal_has_tx_context() const;
  public:
  void clear_tx_context();
  const ::teevm::TxContext& tx_context() const;
  PROTOBUF_NODISCARD ::teevm::TxContext* release_tx_context();
  ::teevm::TxContext* mutable_tx_context();
  void set_allocated_tx_context(::teevm::TxContext* tx_context);
  private:
  const ::teevm::TxContext& _internal_tx_context() const;
  ::teevm::TxContext* _internal_mutable_tx_context();
  public:
  void unsafe_arena_set_allocated_tx_context(
      ::teevm::TxContext* tx_context);
  ::teevm::TxContext* unsafe_arena_release_tx_context();

  // uint64 gas_used = 6;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.TxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TxRequest_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::teevm::TxContext* tx_context_;
    uint64_t gas_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class TxContext_WriteMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxContext_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxContext_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TxContext_WriteMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TxContext_WriteMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TxContext_WriteMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TxContext_WriteMapEntry_DoNotUse& other);
  static const TxContext_WriteMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TxContext_WriteMapEntry_DoNotUse*>(&_TxContext_WriteMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.TxContext.WriteMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class TxContext_ReadMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxContext_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxContext_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TxContext_ReadMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TxContext_ReadMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TxContext_ReadMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TxContext_ReadMapEntry_DoNotUse& other);
  static const TxContext_ReadMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TxContext_ReadMapEntry_DoNotUse*>(&_TxContext_ReadMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.TxContext.ReadMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class TxContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.TxContext) */ {
 public:
  inline TxContext() : TxContext(nullptr) {}
  ~TxContext() override;
  explicit PROTOBUF_CONSTEXPR TxContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxContext(const TxContext& from);
  TxContext(TxContext&& from) noexcept
    : TxContext() {
    *this = ::std::move(from);
  }

  inline TxContext& operator=(const TxContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxContext& operator=(TxContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxContext* internal_default_instance() {
    return reinterpret_cast<const TxContext*>(
               &_TxContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TxContext& a, TxContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TxContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxContext& from) {
    TxContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.TxContext";
  }
  protected:
  explicit TxContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWriteMapFieldNumber = 1,
    kReadMapFieldNumber = 2,
  };
  // map<string, bytes> write_map = 1;
  int write_map_size() const;
  private:
  int _internal_write_map_size() const;
  public:
  void clear_write_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_write_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_write_map();

  // map<string, bytes> read_map = 2;
  int read_map_size() const;
  private:
  int _internal_read_map_size() const;
  public:
  void clear_read_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_read_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_read_map();

  // @@protoc_insertion_point(class_scope:teevm.TxContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TxContext_WriteMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> write_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TxContext_ReadMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> read_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class TxResponse_WriteMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxResponse_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxResponse_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TxResponse_WriteMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TxResponse_WriteMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TxResponse_WriteMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TxResponse_WriteMapEntry_DoNotUse& other);
  static const TxResponse_WriteMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TxResponse_WriteMapEntry_DoNotUse*>(&_TxResponse_WriteMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.TxResponse.WriteMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class TxResponse_ReadMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxResponse_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TxResponse_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TxResponse_ReadMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TxResponse_ReadMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TxResponse_ReadMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TxResponse_ReadMapEntry_DoNotUse& other);
  static const TxResponse_ReadMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TxResponse_ReadMapEntry_DoNotUse*>(&_TxResponse_ReadMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.TxResponse.ReadMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class TxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.TxResponse) */ {
 public:
  inline TxResponse() : TxResponse(nullptr) {}
  ~TxResponse() override;
  explicit PROTOBUF_CONSTEXPR TxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxResponse(const TxResponse& from);
  TxResponse(TxResponse&& from) noexcept
    : TxResponse() {
    *this = ::std::move(from);
  }

  inline TxResponse& operator=(const TxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxResponse& operator=(TxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxResponse* internal_default_instance() {
    return reinterpret_cast<const TxResponse*>(
               &_TxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TxResponse& a, TxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxResponse& from) {
    TxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.TxResponse";
  }
  protected:
  explicit TxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWriteMapFieldNumber = 5,
    kReadMapFieldNumber = 6,
    kEventsFieldNumber = 7,
    kTxIdFieldNumber = 1,
    kResultFieldNumber = 3,
    kMessageFieldNumber = 4,
    kContractNameFieldNumber = 8,
    kContractVersionFieldNumber = 9,
    kChainIdFieldNumber = 10,
    kGasUsedFieldNumber = 11,
    kCodeFieldNumber = 2,
  };
  // map<string, bytes> write_map = 5;
  int write_map_size() const;
  private:
  int _internal_write_map_size() const;
  public:
  void clear_write_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_write_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_write_map();

  // map<string, bytes> read_map = 6;
  int read_map_size() const;
  private:
  int _internal_read_map_size() const;
  public:
  void clear_read_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_read_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_read_map();

  // repeated .teevm.TeeContractEvent events = 7;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::teevm::TeeContractEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >*
      mutable_events();
  private:
  const ::teevm::TeeContractEvent& _internal_events(int index) const;
  ::teevm::TeeContractEvent* _internal_add_events();
  public:
  const ::teevm::TeeContractEvent& events(int index) const;
  ::teevm::TeeContractEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >&
      events() const;

  // string tx_id = 1;
  void clear_tx_id();
  const std::string& tx_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_id();
  PROTOBUF_NODISCARD std::string* release_tx_id();
  void set_allocated_tx_id(std::string* tx_id);
  private:
  const std::string& _internal_tx_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_id(const std::string& value);
  std::string* _internal_mutable_tx_id();
  public:

  // bytes result = 3;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string contract_name = 8;
  void clear_contract_name();
  const std::string& contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_name();
  PROTOBUF_NODISCARD std::string* release_contract_name();
  void set_allocated_contract_name(std::string* contract_name);
  private:
  const std::string& _internal_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_name(const std::string& value);
  std::string* _internal_mutable_contract_name();
  public:

  // string contract_version = 9;
  void clear_contract_version();
  const std::string& contract_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_version();
  PROTOBUF_NODISCARD std::string* release_contract_version();
  void set_allocated_contract_version(std::string* contract_version);
  private:
  const std::string& _internal_contract_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_version(const std::string& value);
  std::string* _internal_mutable_contract_version();
  public:

  // string chain_id = 10;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // uint64 gas_used = 11;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // .teevm.TeeVMCode code = 2;
  void clear_code();
  ::teevm::TeeVMCode code() const;
  void set_code(::teevm::TeeVMCode value);
  private:
  ::teevm::TeeVMCode _internal_code() const;
  void _internal_set_code(::teevm::TeeVMCode value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.TxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TxResponse_WriteMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> write_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TxResponse_ReadMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> read_map_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
    uint64_t gas_used_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class TeeContractEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.TeeContractEvent) */ {
 public:
  inline TeeContractEvent() : TeeContractEvent(nullptr) {}
  ~TeeContractEvent() override;
  explicit PROTOBUF_CONSTEXPR TeeContractEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeeContractEvent(const TeeContractEvent& from);
  TeeContractEvent(TeeContractEvent&& from) noexcept
    : TeeContractEvent() {
    *this = ::std::move(from);
  }

  inline TeeContractEvent& operator=(const TeeContractEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeeContractEvent& operator=(TeeContractEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeeContractEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeeContractEvent* internal_default_instance() {
    return reinterpret_cast<const TeeContractEvent*>(
               &_TeeContractEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TeeContractEvent& a, TeeContractEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TeeContractEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeeContractEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeeContractEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeeContractEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeeContractEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeeContractEvent& from) {
    TeeContractEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeeContractEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.TeeContractEvent";
  }
  protected:
  explicit TeeContractEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kTopicFieldNumber = 1,
    kContractNameFieldNumber = 2,
  };
  // repeated string data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string contract_name = 2;
  void clear_contract_name();
  const std::string& contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_name();
  PROTOBUF_NODISCARD std::string* release_contract_name();
  void set_allocated_contract_name(std::string* contract_name);
  private:
  const std::string& _internal_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_name(const std::string& value);
  std::string* _internal_mutable_contract_name();
  public:

  // @@protoc_insertion_point(class_scope:teevm.TeeContractEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class CallContractRequest_ArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CallContractRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CallContractRequest_ArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  CallContractRequest_ArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CallContractRequest_ArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CallContractRequest_ArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CallContractRequest_ArgsEntry_DoNotUse& other);
  static const CallContractRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CallContractRequest_ArgsEntry_DoNotUse*>(&_CallContractRequest_ArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.CallContractRequest.ArgsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class CallContractRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.CallContractRequest) */ {
 public:
  inline CallContractRequest() : CallContractRequest(nullptr) {}
  ~CallContractRequest() override;
  explicit PROTOBUF_CONSTEXPR CallContractRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallContractRequest(const CallContractRequest& from);
  CallContractRequest(CallContractRequest&& from) noexcept
    : CallContractRequest() {
    *this = ::std::move(from);
  }

  inline CallContractRequest& operator=(const CallContractRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallContractRequest& operator=(CallContractRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallContractRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallContractRequest* internal_default_instance() {
    return reinterpret_cast<const CallContractRequest*>(
               &_CallContractRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CallContractRequest& a, CallContractRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallContractRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallContractRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallContractRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallContractRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallContractRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallContractRequest& from) {
    CallContractRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallContractRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.CallContractRequest";
  }
  protected:
  explicit CallContractRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kContractNameFieldNumber = 1,
  };
  // map<string, bytes> args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_args();

  // string contract_name = 1;
  void clear_contract_name();
  const std::string& contract_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_name();
  PROTOBUF_NODISCARD std::string* release_contract_name();
  void set_allocated_contract_name(std::string* contract_name);
  private:
  const std::string& _internal_contract_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_name(const std::string& value);
  std::string* _internal_mutable_contract_name();
  public:

  // @@protoc_insertion_point(class_scope:teevm.CallContractRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CallContractRequest_ArgsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:teevm.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ContractResponse_WriteMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractResponse_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractResponse_WriteMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ContractResponse_WriteMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ContractResponse_WriteMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ContractResponse_WriteMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ContractResponse_WriteMapEntry_DoNotUse& other);
  static const ContractResponse_WriteMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContractResponse_WriteMapEntry_DoNotUse*>(&_ContractResponse_WriteMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.ContractResponse.WriteMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class ContractResponse_ReadMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractResponse_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractResponse_ReadMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ContractResponse_ReadMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ContractResponse_ReadMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ContractResponse_ReadMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ContractResponse_ReadMapEntry_DoNotUse& other);
  static const ContractResponse_ReadMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContractResponse_ReadMapEntry_DoNotUse*>(&_ContractResponse_ReadMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "teevm.ContractResponse.ReadMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};

// -------------------------------------------------------------------

class ContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:teevm.ContractResponse) */ {
 public:
  inline ContractResponse() : ContractResponse(nullptr) {}
  ~ContractResponse() override;
  explicit PROTOBUF_CONSTEXPR ContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractResponse(const ContractResponse& from);
  ContractResponse(ContractResponse&& from) noexcept
    : ContractResponse() {
    *this = ::std::move(from);
  }

  inline ContractResponse& operator=(const ContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractResponse& operator=(ContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractResponse* internal_default_instance() {
    return reinterpret_cast<const ContractResponse*>(
               &_ContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ContractResponse& a, ContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractResponse& from) {
    ContractResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "teevm.ContractResponse";
  }
  protected:
  explicit ContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWriteMapFieldNumber = 2,
    kReadMapFieldNumber = 3,
    kEventsFieldNumber = 4,
    kResponseFieldNumber = 1,
  };
  // map<string, bytes> write_map = 2;
  int write_map_size() const;
  private:
  int _internal_write_map_size() const;
  public:
  void clear_write_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_write_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      write_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_write_map();

  // map<string, bytes> read_map = 3;
  int read_map_size() const;
  private:
  int _internal_read_map_size() const;
  public:
  void clear_read_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_read_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      read_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_read_map();

  // repeated .teevm.TeeContractEvent events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::teevm::TeeContractEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >*
      mutable_events();
  private:
  const ::teevm::TeeContractEvent& _internal_events(int index) const;
  ::teevm::TeeContractEvent* _internal_add_events();
  public:
  const ::teevm::TeeContractEvent& events(int index) const;
  ::teevm::TeeContractEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >&
      events() const;

  // .teevm.Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::teevm::Response& response() const;
  PROTOBUF_NODISCARD ::teevm::Response* release_response();
  ::teevm::Response* mutable_response();
  void set_allocated_response(::teevm::Response* response);
  private:
  const ::teevm::Response& _internal_response() const;
  ::teevm::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::teevm::Response* response);
  ::teevm::Response* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:teevm.ContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ContractResponse_WriteMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> write_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ContractResponse_ReadMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> read_map_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent > events_;
    ::teevm::Response* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_teevm_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TeeVMMessage

// string tx_id = 1;
inline void TeeVMMessage::clear_tx_id() {
  _impl_.tx_id_.ClearToEmpty();
}
inline const std::string& TeeVMMessage::tx_id() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.tx_id)
  return _internal_tx_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeeVMMessage::set_tx_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TeeVMMessage.tx_id)
}
inline std::string* TeeVMMessage::mutable_tx_id() {
  std::string* _s = _internal_mutable_tx_id();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.tx_id)
  return _s;
}
inline const std::string& TeeVMMessage::_internal_tx_id() const {
  return _impl_.tx_id_.Get();
}
inline void TeeVMMessage::_internal_set_tx_id(const std::string& value) {
  
  _impl_.tx_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TeeVMMessage::_internal_mutable_tx_id() {
  
  return _impl_.tx_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TeeVMMessage::release_tx_id() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.tx_id)
  return _impl_.tx_id_.Release();
}
inline void TeeVMMessage::set_allocated_tx_id(std::string* tx_id) {
  if (tx_id != nullptr) {
    
  } else {
    
  }
  _impl_.tx_id_.SetAllocated(tx_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_id_.IsDefault()) {
    _impl_.tx_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.tx_id)
}

// .teevm.TeeVMType type = 2;
inline void TeeVMMessage::clear_type() {
  _impl_.type_ = 0;
}
inline ::teevm::TeeVMType TeeVMMessage::_internal_type() const {
  return static_cast< ::teevm::TeeVMType >(_impl_.type_);
}
inline ::teevm::TeeVMType TeeVMMessage::type() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.type)
  return _internal_type();
}
inline void TeeVMMessage::_internal_set_type(::teevm::TeeVMType value) {
  
  _impl_.type_ = value;
}
inline void TeeVMMessage::set_type(::teevm::TeeVMType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:teevm.TeeVMMessage.type)
}

// .teevm.CrossContext cross_context = 3;
inline bool TeeVMMessage::_internal_has_cross_context() const {
  return this != internal_default_instance() && _impl_.cross_context_ != nullptr;
}
inline bool TeeVMMessage::has_cross_context() const {
  return _internal_has_cross_context();
}
inline void TeeVMMessage::clear_cross_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.cross_context_ != nullptr) {
    delete _impl_.cross_context_;
  }
  _impl_.cross_context_ = nullptr;
}
inline const ::teevm::CrossContext& TeeVMMessage::_internal_cross_context() const {
  const ::teevm::CrossContext* p = _impl_.cross_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::CrossContext&>(
      ::teevm::_CrossContext_default_instance_);
}
inline const ::teevm::CrossContext& TeeVMMessage::cross_context() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.cross_context)
  return _internal_cross_context();
}
inline void TeeVMMessage::unsafe_arena_set_allocated_cross_context(
    ::teevm::CrossContext* cross_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cross_context_);
  }
  _impl_.cross_context_ = cross_context;
  if (cross_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.TeeVMMessage.cross_context)
}
inline ::teevm::CrossContext* TeeVMMessage::release_cross_context() {
  
  ::teevm::CrossContext* temp = _impl_.cross_context_;
  _impl_.cross_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::CrossContext* TeeVMMessage::unsafe_arena_release_cross_context() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.cross_context)
  
  ::teevm::CrossContext* temp = _impl_.cross_context_;
  _impl_.cross_context_ = nullptr;
  return temp;
}
inline ::teevm::CrossContext* TeeVMMessage::_internal_mutable_cross_context() {
  
  if (_impl_.cross_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::CrossContext>(GetArenaForAllocation());
    _impl_.cross_context_ = p;
  }
  return _impl_.cross_context_;
}
inline ::teevm::CrossContext* TeeVMMessage::mutable_cross_context() {
  ::teevm::CrossContext* _msg = _internal_mutable_cross_context();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.cross_context)
  return _msg;
}
inline void TeeVMMessage::set_allocated_cross_context(::teevm::CrossContext* cross_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cross_context_;
  }
  if (cross_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cross_context);
    if (message_arena != submessage_arena) {
      cross_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cross_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cross_context_ = cross_context;
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.cross_context)
}

// .teevm.SysCallMessage sys_call_message = 4;
inline bool TeeVMMessage::_internal_has_sys_call_message() const {
  return this != internal_default_instance() && _impl_.sys_call_message_ != nullptr;
}
inline bool TeeVMMessage::has_sys_call_message() const {
  return _internal_has_sys_call_message();
}
inline void TeeVMMessage::clear_sys_call_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.sys_call_message_ != nullptr) {
    delete _impl_.sys_call_message_;
  }
  _impl_.sys_call_message_ = nullptr;
}
inline const ::teevm::SysCallMessage& TeeVMMessage::_internal_sys_call_message() const {
  const ::teevm::SysCallMessage* p = _impl_.sys_call_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::SysCallMessage&>(
      ::teevm::_SysCallMessage_default_instance_);
}
inline const ::teevm::SysCallMessage& TeeVMMessage::sys_call_message() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.sys_call_message)
  return _internal_sys_call_message();
}
inline void TeeVMMessage::unsafe_arena_set_allocated_sys_call_message(
    ::teevm::SysCallMessage* sys_call_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sys_call_message_);
  }
  _impl_.sys_call_message_ = sys_call_message;
  if (sys_call_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.TeeVMMessage.sys_call_message)
}
inline ::teevm::SysCallMessage* TeeVMMessage::release_sys_call_message() {
  
  ::teevm::SysCallMessage* temp = _impl_.sys_call_message_;
  _impl_.sys_call_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::SysCallMessage* TeeVMMessage::unsafe_arena_release_sys_call_message() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.sys_call_message)
  
  ::teevm::SysCallMessage* temp = _impl_.sys_call_message_;
  _impl_.sys_call_message_ = nullptr;
  return temp;
}
inline ::teevm::SysCallMessage* TeeVMMessage::_internal_mutable_sys_call_message() {
  
  if (_impl_.sys_call_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::SysCallMessage>(GetArenaForAllocation());
    _impl_.sys_call_message_ = p;
  }
  return _impl_.sys_call_message_;
}
inline ::teevm::SysCallMessage* TeeVMMessage::mutable_sys_call_message() {
  ::teevm::SysCallMessage* _msg = _internal_mutable_sys_call_message();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.sys_call_message)
  return _msg;
}
inline void TeeVMMessage::set_allocated_sys_call_message(::teevm::SysCallMessage* sys_call_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sys_call_message_;
  }
  if (sys_call_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sys_call_message);
    if (message_arena != submessage_arena) {
      sys_call_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sys_call_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sys_call_message_ = sys_call_message;
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.sys_call_message)
}

// .teevm.TxRequest request = 5;
inline bool TeeVMMessage::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool TeeVMMessage::has_request() const {
  return _internal_has_request();
}
inline void TeeVMMessage::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::teevm::TxRequest& TeeVMMessage::_internal_request() const {
  const ::teevm::TxRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::TxRequest&>(
      ::teevm::_TxRequest_default_instance_);
}
inline const ::teevm::TxRequest& TeeVMMessage::request() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.request)
  return _internal_request();
}
inline void TeeVMMessage::unsafe_arena_set_allocated_request(
    ::teevm::TxRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.TeeVMMessage.request)
}
inline ::teevm::TxRequest* TeeVMMessage::release_request() {
  
  ::teevm::TxRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::TxRequest* TeeVMMessage::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.request)
  
  ::teevm::TxRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::teevm::TxRequest* TeeVMMessage::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::TxRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::teevm::TxRequest* TeeVMMessage::mutable_request() {
  ::teevm::TxRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.request)
  return _msg;
}
inline void TeeVMMessage::set_allocated_request(::teevm::TxRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.request)
}

// .teevm.TxResponse response = 6;
inline bool TeeVMMessage::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool TeeVMMessage::has_response() const {
  return _internal_has_response();
}
inline void TeeVMMessage::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::teevm::TxResponse& TeeVMMessage::_internal_response() const {
  const ::teevm::TxResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::TxResponse&>(
      ::teevm::_TxResponse_default_instance_);
}
inline const ::teevm::TxResponse& TeeVMMessage::response() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.response)
  return _internal_response();
}
inline void TeeVMMessage::unsafe_arena_set_allocated_response(
    ::teevm::TxResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.TeeVMMessage.response)
}
inline ::teevm::TxResponse* TeeVMMessage::release_response() {
  
  ::teevm::TxResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::TxResponse* TeeVMMessage::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.response)
  
  ::teevm::TxResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::teevm::TxResponse* TeeVMMessage::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::TxResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::teevm::TxResponse* TeeVMMessage::mutable_response() {
  ::teevm::TxResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.response)
  return _msg;
}
inline void TeeVMMessage::set_allocated_response(::teevm::TxResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.response)
}

// string chain_id = 7;
inline void TeeVMMessage::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& TeeVMMessage::chain_id() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeeVMMessage::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chain_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TeeVMMessage.chain_id)
}
inline std::string* TeeVMMessage::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.chain_id)
  return _s;
}
inline const std::string& TeeVMMessage::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void TeeVMMessage::_internal_set_chain_id(const std::string& value) {
  
  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TeeVMMessage::_internal_mutable_chain_id() {
  
  return _impl_.chain_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TeeVMMessage::release_chain_id() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.chain_id)
  return _impl_.chain_id_.Release();
}
inline void TeeVMMessage::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  _impl_.chain_id_.SetAllocated(chain_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chain_id_.IsDefault()) {
    _impl_.chain_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.chain_id)
}

// bytes sign = 8;
inline void TeeVMMessage::clear_sign() {
  _impl_.sign_.ClearToEmpty();
}
inline const std::string& TeeVMMessage::sign() const {
  // @@protoc_insertion_point(field_get:teevm.TeeVMMessage.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeeVMMessage::set_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TeeVMMessage.sign)
}
inline std::string* TeeVMMessage::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:teevm.TeeVMMessage.sign)
  return _s;
}
inline const std::string& TeeVMMessage::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void TeeVMMessage::_internal_set_sign(const std::string& value) {
  
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* TeeVMMessage::_internal_mutable_sign() {
  
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* TeeVMMessage::release_sign() {
  // @@protoc_insertion_point(field_release:teevm.TeeVMMessage.sign)
  return _impl_.sign_.Release();
}
inline void TeeVMMessage::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeVMMessage.sign)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SysCallMessage

// .teevm.TeeVMCode code = 1;
inline void SysCallMessage::clear_code() {
  _impl_.code_ = 0;
}
inline ::teevm::TeeVMCode SysCallMessage::_internal_code() const {
  return static_cast< ::teevm::TeeVMCode >(_impl_.code_);
}
inline ::teevm::TeeVMCode SysCallMessage::code() const {
  // @@protoc_insertion_point(field_get:teevm.SysCallMessage.code)
  return _internal_code();
}
inline void SysCallMessage::_internal_set_code(::teevm::TeeVMCode value) {
  
  _impl_.code_ = value;
}
inline void SysCallMessage::set_code(::teevm::TeeVMCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:teevm.SysCallMessage.code)
}

// string message = 2;
inline void SysCallMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SysCallMessage::message() const {
  // @@protoc_insertion_point(field_get:teevm.SysCallMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SysCallMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.SysCallMessage.message)
}
inline std::string* SysCallMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:teevm.SysCallMessage.message)
  return _s;
}
inline const std::string& SysCallMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SysCallMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SysCallMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SysCallMessage::release_message() {
  // @@protoc_insertion_point(field_release:teevm.SysCallMessage.message)
  return _impl_.message_.Release();
}
inline void SysCallMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.SysCallMessage.message)
}

// map<string, bytes> payload = 3;
inline int SysCallMessage::_internal_payload_size() const {
  return _impl_.payload_.size();
}
inline int SysCallMessage::payload_size() const {
  return _internal_payload_size();
}
inline void SysCallMessage::clear_payload() {
  _impl_.payload_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SysCallMessage::_internal_payload() const {
  return _impl_.payload_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SysCallMessage::payload() const {
  // @@protoc_insertion_point(field_map:teevm.SysCallMessage.payload)
  return _internal_payload();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SysCallMessage::_internal_mutable_payload() {
  return _impl_.payload_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SysCallMessage::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_map:teevm.SysCallMessage.payload)
  return _internal_mutable_payload();
}

// -------------------------------------------------------------------

// CrossContext

// uint32 current_depth = 1;
inline void CrossContext::clear_current_depth() {
  _impl_.current_depth_ = 0u;
}
inline uint32_t CrossContext::_internal_current_depth() const {
  return _impl_.current_depth_;
}
inline uint32_t CrossContext::current_depth() const {
  // @@protoc_insertion_point(field_get:teevm.CrossContext.current_depth)
  return _internal_current_depth();
}
inline void CrossContext::_internal_set_current_depth(uint32_t value) {
  
  _impl_.current_depth_ = value;
}
inline void CrossContext::set_current_depth(uint32_t value) {
  _internal_set_current_depth(value);
  // @@protoc_insertion_point(field_set:teevm.CrossContext.current_depth)
}

// string process_name = 2;
inline void CrossContext::clear_process_name() {
  _impl_.process_name_.ClearToEmpty();
}
inline const std::string& CrossContext::process_name() const {
  // @@protoc_insertion_point(field_get:teevm.CrossContext.process_name)
  return _internal_process_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CrossContext::set_process_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.process_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.CrossContext.process_name)
}
inline std::string* CrossContext::mutable_process_name() {
  std::string* _s = _internal_mutable_process_name();
  // @@protoc_insertion_point(field_mutable:teevm.CrossContext.process_name)
  return _s;
}
inline const std::string& CrossContext::_internal_process_name() const {
  return _impl_.process_name_.Get();
}
inline void CrossContext::_internal_set_process_name(const std::string& value) {
  
  _impl_.process_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CrossContext::_internal_mutable_process_name() {
  
  return _impl_.process_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CrossContext::release_process_name() {
  // @@protoc_insertion_point(field_release:teevm.CrossContext.process_name)
  return _impl_.process_name_.Release();
}
inline void CrossContext::set_allocated_process_name(std::string* process_name) {
  if (process_name != nullptr) {
    
  } else {
    
  }
  _impl_.process_name_.SetAllocated(process_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.process_name_.IsDefault()) {
    _impl_.process_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.CrossContext.process_name)
}

// uint64 cross_info = 3;
inline void CrossContext::clear_cross_info() {
  _impl_.cross_info_ = uint64_t{0u};
}
inline uint64_t CrossContext::_internal_cross_info() const {
  return _impl_.cross_info_;
}
inline uint64_t CrossContext::cross_info() const {
  // @@protoc_insertion_point(field_get:teevm.CrossContext.cross_info)
  return _internal_cross_info();
}
inline void CrossContext::_internal_set_cross_info(uint64_t value) {
  
  _impl_.cross_info_ = value;
}
inline void CrossContext::set_cross_info(uint64_t value) {
  _internal_set_cross_info(value);
  // @@protoc_insertion_point(field_set:teevm.CrossContext.cross_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TxRequest

// string contract_name = 1;
inline void TxRequest::clear_contract_name() {
  _impl_.contract_name_.ClearToEmpty();
}
inline const std::string& TxRequest::contract_name() const {
  // @@protoc_insertion_point(field_get:teevm.TxRequest.contract_name)
  return _internal_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxRequest::set_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxRequest.contract_name)
}
inline std::string* TxRequest::mutable_contract_name() {
  std::string* _s = _internal_mutable_contract_name();
  // @@protoc_insertion_point(field_mutable:teevm.TxRequest.contract_name)
  return _s;
}
inline const std::string& TxRequest::_internal_contract_name() const {
  return _impl_.contract_name_.Get();
}
inline void TxRequest::_internal_set_contract_name(const std::string& value) {
  
  _impl_.contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TxRequest::_internal_mutable_contract_name() {
  
  return _impl_.contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TxRequest::release_contract_name() {
  // @@protoc_insertion_point(field_release:teevm.TxRequest.contract_name)
  return _impl_.contract_name_.Release();
}
inline void TxRequest::set_allocated_contract_name(std::string* contract_name) {
  if (contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.contract_name_.SetAllocated(contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_name_.IsDefault()) {
    _impl_.contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxRequest.contract_name)
}

// string contract_version = 2;
inline void TxRequest::clear_contract_version() {
  _impl_.contract_version_.ClearToEmpty();
}
inline const std::string& TxRequest::contract_version() const {
  // @@protoc_insertion_point(field_get:teevm.TxRequest.contract_version)
  return _internal_contract_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxRequest::set_contract_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxRequest.contract_version)
}
inline std::string* TxRequest::mutable_contract_version() {
  std::string* _s = _internal_mutable_contract_version();
  // @@protoc_insertion_point(field_mutable:teevm.TxRequest.contract_version)
  return _s;
}
inline const std::string& TxRequest::_internal_contract_version() const {
  return _impl_.contract_version_.Get();
}
inline void TxRequest::_internal_set_contract_version(const std::string& value) {
  
  _impl_.contract_version_.Set(value, GetArenaForAllocation());
}
inline std::string* TxRequest::_internal_mutable_contract_version() {
  
  return _impl_.contract_version_.Mutable(GetArenaForAllocation());
}
inline std::string* TxRequest::release_contract_version() {
  // @@protoc_insertion_point(field_release:teevm.TxRequest.contract_version)
  return _impl_.contract_version_.Release();
}
inline void TxRequest::set_allocated_contract_version(std::string* contract_version) {
  if (contract_version != nullptr) {
    
  } else {
    
  }
  _impl_.contract_version_.SetAllocated(contract_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_version_.IsDefault()) {
    _impl_.contract_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxRequest.contract_version)
}

// string method = 3;
inline void TxRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& TxRequest::method() const {
  // @@protoc_insertion_point(field_get:teevm.TxRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxRequest.method)
}
inline std::string* TxRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:teevm.TxRequest.method)
  return _s;
}
inline const std::string& TxRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void TxRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* TxRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* TxRequest::release_method() {
  // @@protoc_insertion_point(field_release:teevm.TxRequest.method)
  return _impl_.method_.Release();
}
inline void TxRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxRequest.method)
}

// map<string, bytes> parameters = 4;
inline int TxRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int TxRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void TxRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxRequest::parameters() const {
  // @@protoc_insertion_point(field_map:teevm.TxRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:teevm.TxRequest.parameters)
  return _internal_mutable_parameters();
}

// .teevm.TxContext tx_context = 5;
inline bool TxRequest::_internal_has_tx_context() const {
  return this != internal_default_instance() && _impl_.tx_context_ != nullptr;
}
inline bool TxRequest::has_tx_context() const {
  return _internal_has_tx_context();
}
inline void TxRequest::clear_tx_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.tx_context_ != nullptr) {
    delete _impl_.tx_context_;
  }
  _impl_.tx_context_ = nullptr;
}
inline const ::teevm::TxContext& TxRequest::_internal_tx_context() const {
  const ::teevm::TxContext* p = _impl_.tx_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::TxContext&>(
      ::teevm::_TxContext_default_instance_);
}
inline const ::teevm::TxContext& TxRequest::tx_context() const {
  // @@protoc_insertion_point(field_get:teevm.TxRequest.tx_context)
  return _internal_tx_context();
}
inline void TxRequest::unsafe_arena_set_allocated_tx_context(
    ::teevm::TxContext* tx_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_context_);
  }
  _impl_.tx_context_ = tx_context;
  if (tx_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.TxRequest.tx_context)
}
inline ::teevm::TxContext* TxRequest::release_tx_context() {
  
  ::teevm::TxContext* temp = _impl_.tx_context_;
  _impl_.tx_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::TxContext* TxRequest::unsafe_arena_release_tx_context() {
  // @@protoc_insertion_point(field_release:teevm.TxRequest.tx_context)
  
  ::teevm::TxContext* temp = _impl_.tx_context_;
  _impl_.tx_context_ = nullptr;
  return temp;
}
inline ::teevm::TxContext* TxRequest::_internal_mutable_tx_context() {
  
  if (_impl_.tx_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::TxContext>(GetArenaForAllocation());
    _impl_.tx_context_ = p;
  }
  return _impl_.tx_context_;
}
inline ::teevm::TxContext* TxRequest::mutable_tx_context() {
  ::teevm::TxContext* _msg = _internal_mutable_tx_context();
  // @@protoc_insertion_point(field_mutable:teevm.TxRequest.tx_context)
  return _msg;
}
inline void TxRequest::set_allocated_tx_context(::teevm::TxContext* tx_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tx_context_;
  }
  if (tx_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_context);
    if (message_arena != submessage_arena) {
      tx_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tx_context_ = tx_context;
  // @@protoc_insertion_point(field_set_allocated:teevm.TxRequest.tx_context)
}

// uint64 gas_used = 6;
inline void TxRequest::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t TxRequest::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t TxRequest::gas_used() const {
  // @@protoc_insertion_point(field_get:teevm.TxRequest.gas_used)
  return _internal_gas_used();
}
inline void TxRequest::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void TxRequest::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:teevm.TxRequest.gas_used)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TxContext

// map<string, bytes> write_map = 1;
inline int TxContext::_internal_write_map_size() const {
  return _impl_.write_map_.size();
}
inline int TxContext::write_map_size() const {
  return _internal_write_map_size();
}
inline void TxContext::clear_write_map() {
  _impl_.write_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxContext::_internal_write_map() const {
  return _impl_.write_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxContext::write_map() const {
  // @@protoc_insertion_point(field_map:teevm.TxContext.write_map)
  return _internal_write_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxContext::_internal_mutable_write_map() {
  return _impl_.write_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxContext::mutable_write_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.TxContext.write_map)
  return _internal_mutable_write_map();
}

// map<string, bytes> read_map = 2;
inline int TxContext::_internal_read_map_size() const {
  return _impl_.read_map_.size();
}
inline int TxContext::read_map_size() const {
  return _internal_read_map_size();
}
inline void TxContext::clear_read_map() {
  _impl_.read_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxContext::_internal_read_map() const {
  return _impl_.read_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxContext::read_map() const {
  // @@protoc_insertion_point(field_map:teevm.TxContext.read_map)
  return _internal_read_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxContext::_internal_mutable_read_map() {
  return _impl_.read_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxContext::mutable_read_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.TxContext.read_map)
  return _internal_mutable_read_map();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TxResponse

// string tx_id = 1;
inline void TxResponse::clear_tx_id() {
  _impl_.tx_id_.ClearToEmpty();
}
inline const std::string& TxResponse::tx_id() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.tx_id)
  return _internal_tx_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_tx_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.tx_id)
}
inline std::string* TxResponse::mutable_tx_id() {
  std::string* _s = _internal_mutable_tx_id();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.tx_id)
  return _s;
}
inline const std::string& TxResponse::_internal_tx_id() const {
  return _impl_.tx_id_.Get();
}
inline void TxResponse::_internal_set_tx_id(const std::string& value) {
  
  _impl_.tx_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_tx_id() {
  
  return _impl_.tx_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_tx_id() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.tx_id)
  return _impl_.tx_id_.Release();
}
inline void TxResponse::set_allocated_tx_id(std::string* tx_id) {
  if (tx_id != nullptr) {
    
  } else {
    
  }
  _impl_.tx_id_.SetAllocated(tx_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_id_.IsDefault()) {
    _impl_.tx_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.tx_id)
}

// .teevm.TeeVMCode code = 2;
inline void TxResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::teevm::TeeVMCode TxResponse::_internal_code() const {
  return static_cast< ::teevm::TeeVMCode >(_impl_.code_);
}
inline ::teevm::TeeVMCode TxResponse::code() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.code)
  return _internal_code();
}
inline void TxResponse::_internal_set_code(::teevm::TeeVMCode value) {
  
  _impl_.code_ = value;
}
inline void TxResponse::set_code(::teevm::TeeVMCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:teevm.TxResponse.code)
}

// bytes result = 3;
inline void TxResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& TxResponse::result() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.result)
}
inline std::string* TxResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.result)
  return _s;
}
inline const std::string& TxResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void TxResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_result() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.result)
  return _impl_.result_.Release();
}
inline void TxResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.result)
}

// string message = 4;
inline void TxResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& TxResponse::message() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.message)
}
inline std::string* TxResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.message)
  return _s;
}
inline const std::string& TxResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void TxResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_message() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.message)
  return _impl_.message_.Release();
}
inline void TxResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.message)
}

// map<string, bytes> write_map = 5;
inline int TxResponse::_internal_write_map_size() const {
  return _impl_.write_map_.size();
}
inline int TxResponse::write_map_size() const {
  return _internal_write_map_size();
}
inline void TxResponse::clear_write_map() {
  _impl_.write_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxResponse::_internal_write_map() const {
  return _impl_.write_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxResponse::write_map() const {
  // @@protoc_insertion_point(field_map:teevm.TxResponse.write_map)
  return _internal_write_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxResponse::_internal_mutable_write_map() {
  return _impl_.write_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxResponse::mutable_write_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.TxResponse.write_map)
  return _internal_mutable_write_map();
}

// map<string, bytes> read_map = 6;
inline int TxResponse::_internal_read_map_size() const {
  return _impl_.read_map_.size();
}
inline int TxResponse::read_map_size() const {
  return _internal_read_map_size();
}
inline void TxResponse::clear_read_map() {
  _impl_.read_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxResponse::_internal_read_map() const {
  return _impl_.read_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TxResponse::read_map() const {
  // @@protoc_insertion_point(field_map:teevm.TxResponse.read_map)
  return _internal_read_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxResponse::_internal_mutable_read_map() {
  return _impl_.read_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TxResponse::mutable_read_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.TxResponse.read_map)
  return _internal_mutable_read_map();
}

// repeated .teevm.TeeContractEvent events = 7;
inline int TxResponse::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int TxResponse::events_size() const {
  return _internal_events_size();
}
inline void TxResponse::clear_events() {
  _impl_.events_.Clear();
}
inline ::teevm::TeeContractEvent* TxResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >*
TxResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:teevm.TxResponse.events)
  return &_impl_.events_;
}
inline const ::teevm::TeeContractEvent& TxResponse::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::teevm::TeeContractEvent& TxResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.events)
  return _internal_events(index);
}
inline ::teevm::TeeContractEvent* TxResponse::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::teevm::TeeContractEvent* TxResponse::add_events() {
  ::teevm::TeeContractEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:teevm.TxResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >&
TxResponse::events() const {
  // @@protoc_insertion_point(field_list:teevm.TxResponse.events)
  return _impl_.events_;
}

// string contract_name = 8;
inline void TxResponse::clear_contract_name() {
  _impl_.contract_name_.ClearToEmpty();
}
inline const std::string& TxResponse::contract_name() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.contract_name)
  return _internal_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.contract_name)
}
inline std::string* TxResponse::mutable_contract_name() {
  std::string* _s = _internal_mutable_contract_name();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.contract_name)
  return _s;
}
inline const std::string& TxResponse::_internal_contract_name() const {
  return _impl_.contract_name_.Get();
}
inline void TxResponse::_internal_set_contract_name(const std::string& value) {
  
  _impl_.contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_contract_name() {
  
  return _impl_.contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_contract_name() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.contract_name)
  return _impl_.contract_name_.Release();
}
inline void TxResponse::set_allocated_contract_name(std::string* contract_name) {
  if (contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.contract_name_.SetAllocated(contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_name_.IsDefault()) {
    _impl_.contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.contract_name)
}

// string contract_version = 9;
inline void TxResponse::clear_contract_version() {
  _impl_.contract_version_.ClearToEmpty();
}
inline const std::string& TxResponse::contract_version() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.contract_version)
  return _internal_contract_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_contract_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.contract_version)
}
inline std::string* TxResponse::mutable_contract_version() {
  std::string* _s = _internal_mutable_contract_version();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.contract_version)
  return _s;
}
inline const std::string& TxResponse::_internal_contract_version() const {
  return _impl_.contract_version_.Get();
}
inline void TxResponse::_internal_set_contract_version(const std::string& value) {
  
  _impl_.contract_version_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_contract_version() {
  
  return _impl_.contract_version_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_contract_version() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.contract_version)
  return _impl_.contract_version_.Release();
}
inline void TxResponse::set_allocated_contract_version(std::string* contract_version) {
  if (contract_version != nullptr) {
    
  } else {
    
  }
  _impl_.contract_version_.SetAllocated(contract_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_version_.IsDefault()) {
    _impl_.contract_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.contract_version)
}

// string chain_id = 10;
inline void TxResponse::clear_chain_id() {
  _impl_.chain_id_.ClearToEmpty();
}
inline const std::string& TxResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResponse::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chain_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TxResponse.chain_id)
}
inline std::string* TxResponse::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:teevm.TxResponse.chain_id)
  return _s;
}
inline const std::string& TxResponse::_internal_chain_id() const {
  return _impl_.chain_id_.Get();
}
inline void TxResponse::_internal_set_chain_id(const std::string& value) {
  
  _impl_.chain_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TxResponse::_internal_mutable_chain_id() {
  
  return _impl_.chain_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TxResponse::release_chain_id() {
  // @@protoc_insertion_point(field_release:teevm.TxResponse.chain_id)
  return _impl_.chain_id_.Release();
}
inline void TxResponse::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  _impl_.chain_id_.SetAllocated(chain_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chain_id_.IsDefault()) {
    _impl_.chain_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TxResponse.chain_id)
}

// uint64 gas_used = 11;
inline void TxResponse::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t TxResponse::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t TxResponse::gas_used() const {
  // @@protoc_insertion_point(field_get:teevm.TxResponse.gas_used)
  return _internal_gas_used();
}
inline void TxResponse::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void TxResponse::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:teevm.TxResponse.gas_used)
}

// -------------------------------------------------------------------

// TeeContractEvent

// string topic = 1;
inline void TeeContractEvent::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& TeeContractEvent::topic() const {
  // @@protoc_insertion_point(field_get:teevm.TeeContractEvent.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeeContractEvent::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TeeContractEvent.topic)
}
inline std::string* TeeContractEvent::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:teevm.TeeContractEvent.topic)
  return _s;
}
inline const std::string& TeeContractEvent::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void TeeContractEvent::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* TeeContractEvent::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* TeeContractEvent::release_topic() {
  // @@protoc_insertion_point(field_release:teevm.TeeContractEvent.topic)
  return _impl_.topic_.Release();
}
inline void TeeContractEvent::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeContractEvent.topic)
}

// string contract_name = 2;
inline void TeeContractEvent::clear_contract_name() {
  _impl_.contract_name_.ClearToEmpty();
}
inline const std::string& TeeContractEvent::contract_name() const {
  // @@protoc_insertion_point(field_get:teevm.TeeContractEvent.contract_name)
  return _internal_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeeContractEvent::set_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.TeeContractEvent.contract_name)
}
inline std::string* TeeContractEvent::mutable_contract_name() {
  std::string* _s = _internal_mutable_contract_name();
  // @@protoc_insertion_point(field_mutable:teevm.TeeContractEvent.contract_name)
  return _s;
}
inline const std::string& TeeContractEvent::_internal_contract_name() const {
  return _impl_.contract_name_.Get();
}
inline void TeeContractEvent::_internal_set_contract_name(const std::string& value) {
  
  _impl_.contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TeeContractEvent::_internal_mutable_contract_name() {
  
  return _impl_.contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TeeContractEvent::release_contract_name() {
  // @@protoc_insertion_point(field_release:teevm.TeeContractEvent.contract_name)
  return _impl_.contract_name_.Release();
}
inline void TeeContractEvent::set_allocated_contract_name(std::string* contract_name) {
  if (contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.contract_name_.SetAllocated(contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_name_.IsDefault()) {
    _impl_.contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.TeeContractEvent.contract_name)
}

// repeated string data = 3;
inline int TeeContractEvent::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int TeeContractEvent::data_size() const {
  return _internal_data_size();
}
inline void TeeContractEvent::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* TeeContractEvent::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:teevm.TeeContractEvent.data)
  return _s;
}
inline const std::string& TeeContractEvent::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& TeeContractEvent::data(int index) const {
  // @@protoc_insertion_point(field_get:teevm.TeeContractEvent.data)
  return _internal_data(index);
}
inline std::string* TeeContractEvent::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:teevm.TeeContractEvent.data)
  return _impl_.data_.Mutable(index);
}
inline void TeeContractEvent::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::set_data(int index, const char* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:teevm.TeeContractEvent.data)
}
inline std::string* TeeContractEvent::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void TeeContractEvent::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:teevm.TeeContractEvent.data)
}
inline void TeeContractEvent::add_data(const char* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:teevm.TeeContractEvent.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeeContractEvent::data() const {
  // @@protoc_insertion_point(field_list:teevm.TeeContractEvent.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeeContractEvent::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:teevm.TeeContractEvent.data)
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CallContractRequest

// string contract_name = 1;
inline void CallContractRequest::clear_contract_name() {
  _impl_.contract_name_.ClearToEmpty();
}
inline const std::string& CallContractRequest::contract_name() const {
  // @@protoc_insertion_point(field_get:teevm.CallContractRequest.contract_name)
  return _internal_contract_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallContractRequest::set_contract_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contract_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.CallContractRequest.contract_name)
}
inline std::string* CallContractRequest::mutable_contract_name() {
  std::string* _s = _internal_mutable_contract_name();
  // @@protoc_insertion_point(field_mutable:teevm.CallContractRequest.contract_name)
  return _s;
}
inline const std::string& CallContractRequest::_internal_contract_name() const {
  return _impl_.contract_name_.Get();
}
inline void CallContractRequest::_internal_set_contract_name(const std::string& value) {
  
  _impl_.contract_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CallContractRequest::_internal_mutable_contract_name() {
  
  return _impl_.contract_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CallContractRequest::release_contract_name() {
  // @@protoc_insertion_point(field_release:teevm.CallContractRequest.contract_name)
  return _impl_.contract_name_.Release();
}
inline void CallContractRequest::set_allocated_contract_name(std::string* contract_name) {
  if (contract_name != nullptr) {
    
  } else {
    
  }
  _impl_.contract_name_.SetAllocated(contract_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contract_name_.IsDefault()) {
    _impl_.contract_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.CallContractRequest.contract_name)
}

// map<string, bytes> args = 2;
inline int CallContractRequest::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int CallContractRequest::args_size() const {
  return _internal_args_size();
}
inline void CallContractRequest::clear_args() {
  _impl_.args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CallContractRequest::_internal_args() const {
  return _impl_.args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CallContractRequest::args() const {
  // @@protoc_insertion_point(field_map:teevm.CallContractRequest.args)
  return _internal_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CallContractRequest::_internal_mutable_args() {
  return _impl_.args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CallContractRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:teevm.CallContractRequest.args)
  return _internal_mutable_args();
}

// -------------------------------------------------------------------

// Response

// int32 status = 1;
inline void Response::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t Response::_internal_status() const {
  return _impl_.status_;
}
inline int32_t Response::status() const {
  // @@protoc_insertion_point(field_get:teevm.Response.status)
  return _internal_status();
}
inline void Response::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void Response::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:teevm.Response.status)
}

// string message = 2;
inline void Response::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Response::message() const {
  // @@protoc_insertion_point(field_get:teevm.Response.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.Response.message)
}
inline std::string* Response::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:teevm.Response.message)
  return _s;
}
inline const std::string& Response::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Response::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_message() {
  // @@protoc_insertion_point(field_release:teevm.Response.message)
  return _impl_.message_.Release();
}
inline void Response::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.Response.message)
}

// bytes payload = 3;
inline void Response::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Response::payload() const {
  // @@protoc_insertion_point(field_get:teevm.Response.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:teevm.Response.payload)
}
inline std::string* Response::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:teevm.Response.payload)
  return _s;
}
inline const std::string& Response::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void Response::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* Response::release_payload() {
  // @@protoc_insertion_point(field_release:teevm.Response.payload)
  return _impl_.payload_.Release();
}
inline void Response::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:teevm.Response.payload)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractResponse

// .teevm.Response response = 1;
inline bool ContractResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ContractResponse::has_response() const {
  return _internal_has_response();
}
inline void ContractResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
inline const ::teevm::Response& ContractResponse::_internal_response() const {
  const ::teevm::Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::teevm::Response&>(
      ::teevm::_Response_default_instance_);
}
inline const ::teevm::Response& ContractResponse::response() const {
  // @@protoc_insertion_point(field_get:teevm.ContractResponse.response)
  return _internal_response();
}
inline void ContractResponse::unsafe_arena_set_allocated_response(
    ::teevm::Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:teevm.ContractResponse.response)
}
inline ::teevm::Response* ContractResponse::release_response() {
  
  ::teevm::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::teevm::Response* ContractResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:teevm.ContractResponse.response)
  
  ::teevm::Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::teevm::Response* ContractResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::teevm::Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::teevm::Response* ContractResponse::mutable_response() {
  ::teevm::Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:teevm.ContractResponse.response)
  return _msg;
}
inline void ContractResponse::set_allocated_response(::teevm::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:teevm.ContractResponse.response)
}

// map<string, bytes> write_map = 2;
inline int ContractResponse::_internal_write_map_size() const {
  return _impl_.write_map_.size();
}
inline int ContractResponse::write_map_size() const {
  return _internal_write_map_size();
}
inline void ContractResponse::clear_write_map() {
  _impl_.write_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractResponse::_internal_write_map() const {
  return _impl_.write_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractResponse::write_map() const {
  // @@protoc_insertion_point(field_map:teevm.ContractResponse.write_map)
  return _internal_write_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractResponse::_internal_mutable_write_map() {
  return _impl_.write_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractResponse::mutable_write_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.ContractResponse.write_map)
  return _internal_mutable_write_map();
}

// map<string, bytes> read_map = 3;
inline int ContractResponse::_internal_read_map_size() const {
  return _impl_.read_map_.size();
}
inline int ContractResponse::read_map_size() const {
  return _internal_read_map_size();
}
inline void ContractResponse::clear_read_map() {
  _impl_.read_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractResponse::_internal_read_map() const {
  return _impl_.read_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractResponse::read_map() const {
  // @@protoc_insertion_point(field_map:teevm.ContractResponse.read_map)
  return _internal_read_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractResponse::_internal_mutable_read_map() {
  return _impl_.read_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractResponse::mutable_read_map() {
  // @@protoc_insertion_point(field_mutable_map:teevm.ContractResponse.read_map)
  return _internal_mutable_read_map();
}

// repeated .teevm.TeeContractEvent events = 4;
inline int ContractResponse::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ContractResponse::events_size() const {
  return _internal_events_size();
}
inline void ContractResponse::clear_events() {
  _impl_.events_.Clear();
}
inline ::teevm::TeeContractEvent* ContractResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:teevm.ContractResponse.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >*
ContractResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:teevm.ContractResponse.events)
  return &_impl_.events_;
}
inline const ::teevm::TeeContractEvent& ContractResponse::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::teevm::TeeContractEvent& ContractResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:teevm.ContractResponse.events)
  return _internal_events(index);
}
inline ::teevm::TeeContractEvent* ContractResponse::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::teevm::TeeContractEvent* ContractResponse::add_events() {
  ::teevm::TeeContractEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:teevm.ContractResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::teevm::TeeContractEvent >&
ContractResponse::events() const {
  // @@protoc_insertion_point(field_list:teevm.ContractResponse.events)
  return _impl_.events_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace teevm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::teevm::TeeVMType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::teevm::TeeVMType>() {
  return ::teevm::TeeVMType_descriptor();
}
template <> struct is_proto_enum< ::teevm::TeeVMCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::teevm::TeeVMCode>() {
  return ::teevm::TeeVMCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_teevm_5fmessage_2eproto
